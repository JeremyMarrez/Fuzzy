def classe(p):
    
    """Retourne la classe d'un polynôme (le maximum parmi les indices des variables apparaissant dans p)"""
    
    if p.is_constant() :
        v = n
        
    elif p.is_zero() :
        v = n
             
    else :
        
        mon = p.lm()
        
        lv = [i for i in range(0, n) if mon.degrees()[i] > 0]
        
        if lv == [] :
            v= n
            
        else :
            
            v = max(lv)
            
    return v

def degre(p):
    
    """Retourne le degré d'un polynôme (le degré maximum en la variable dont l'indice est la classe de p, i.e. la variable principale de p)"""
    
    if p.is_zero():
        
        return -1

    else :
    
        return (p.lm()).degrees()[classe(p)]

def init(p):
    
    """Retourne le coefficient dominant en la variable principale de p"""
    
    return p.coefficient(var[classe(p)]**degre(p))

def ordreRitt(a,b):
    
    """Renvoie 1 si a > b
               0 si a = b
               -1 si a < b
       pour l'ordre de Ritt."""
    
    if a.is_zero() :
        
        if b.is_zero():      
            return int(0)
        
        else :
            return int(-1)
    
    if b.is_zero() :
        return int(1)
    
    if a.is_constant() :
        
        if b.is_constant():      
            return int(0)
        
        else :
            return int(-1)
    
    if b.is_constant() :
        return int(1)
    
    classe_a = classe(a)
    classe_b = classe(b)
    
    diff_classes = classe_a - classe_b
    
    if not(diff_classes == 0):
        return int(diff_classes / abs(diff_classes))
                
    else :
        diff_degres = degre(a) - degre(b)
        
        if not(diff_degres == 0):
            return int(diff_degres / abs(diff_degres))
    
        else:
            return ordreRitt(a.coefficient(var[classe(a)]),b.coefficient(var[classe(b)]))

def estReduit(a,b):
    
    """Renvoie True si a est réduit par rapport à b, et False sinon"""
        
    if b.is_constant():
        return False
    
    return a.degree(var[classe(b)]) < degre(b)

def basicSet(F):
    
    """Calcule un ensemble basique d'un ensemble de polynômes F"""
    
    B = []
    
    while F != []:
              
        b = F[0]
        
        print("L'élément de rang minimal est {0}".format(b))
        
        if b.lc() != 1 and b.lc() !=0:
            b = b/b.lc()

        B.append(b)
        
        F = [f for f in F if estReduit(f,b)]
            
        print("On ne garde dans l'ensemble que les éléments qui sont réduits par rapport à {0}, on obtient l'ensemble {1}".format(b,F))
        
    print("Basic Set B =")
    print(B)        
    return B

def tail(p):
    
    """Renvoie la queue d'un polynôme p, i.e. p - son terme dominant"""
    
    tail = p - init(p)*var[classe(p)]**degre(p)
    
    return tail

def estConstant(p,i):
    
    """Renvoie True si p est constant en la variable d'indice i, et False sinon"""
    
    if classe(p) == i :
        
        return False
    
    if classe(p) == n or classe(p) < i :
        
        return True
    
    return estConstant(tail(p),i)    

def pseudoDiv(p,f):
    
    """Effectue la pseudo-division de p par f
    et renvoie la liste [quotient, reste, init(f), init(f)^j]"""
    
    v = var[classe(f)]
        
    q = 0
        
    deg_f = degre(f)
        
    deg_p = p.degree(var[classe(f)])
        
    h = init(f)
        
    g = tail(f)
     
    delta = deg_p - deg_f
        
    j = 0

    while delta >= 0 :        
        j +=1

        aux = p.coefficient(var[classe(f)]**(p.degree(var[classe(f)])))
        
        q = h*q + aux *v**delta
        p = h*p - aux*f*v**delta
        deg_p = p.degree(var[classe(f)])
        delta = deg_p - deg_f
   
    return [q,p,h**j,j]

def premEnsTri(p,T):
    
    """Effectue la pseudo-division de p par tous les polynômes de l'ensemble T et renvoie le reste"""
    
    for i in range(len(T),0,-1):

        p = pseudoDiv(p,T[i-1])[1]
    
    if p.lc() != 1 and p.lc() !=0:
            p = p/p.lc()
            
    return p

def PREM(F,B):
    
    """Effectue la pseudo-division de chaque polynôme de F par tous les polynômes de l'ensemble T et renvoie la liste des restes"""
    
    PREM = []
    
    for i in range(len(F)):
        
        PREM.append(premEnsTri(F[i],B))
    
    PREM.sort()    
        
    PREM.sort(ordreRitt)    
        
    return PREM

def listeContientUneConstante(L):
    
    """Renvoie True si la liste contient une constante, et False sinon"""
    
    for i in range(0,len(L)):
        
        if L[i].is_constant():
            
            return True
        
        
    return False

def CharacSet(F) :
    
    """Calcule l'ensemble caractéristique de l'ensemble de polynômes F"""
    
    S = list(copy(F))
    print("S =")
    print(S)
    print("Calcul d'un ensemble basique :")
    B = basicSet(S)
    
    while PREM(F,B).count(0) != len(PREM(F,B)):
        
        print("PREM(F,B) =")
        print(PREM(F,B))
        S = set(S)
        S = S.union(PREM(F,B))
        if 0 in S:
            S.remove(0)
        S = list(S)
        S.sort(ordreRitt)  
                
        if listeContientUneConstante(S):
            
            return [1]
        
        else:
        
            print("S ∪ PREM (F,B)\{0} =")
            print(S)
            print("Calcul d'un ensemble basique :")
            B = basicSet(S)
        
        print('retour dans la fonction CharacSet')
    
    print("Charac Set =")
    print(B)
    
    return B           

def Wu(F):
    
    """Algorithme de Wu : calcul de l'ensemble des ensembles caractéristiques à partir du système F"""
    
    Z = []
    D = [F]
    
    while D != []:
        
        print("D =")
        print(D)
        
        Ft = D[0]
        D.remove(Ft)
        
        print("Calcul de l'ensemble caractéristique :")
        
        B = CharacSet(Ft)
        print('retour dans la fonction Wu')
        if B != [1] and B !=[-1]:
            
            Z.append(B)
            
            for b in B :
                
                liste = []
                
                if not init(b).is_constant():
                
                    ens_Ft = set(Ft)
                
                    ens_B = set(B)
                    
                    ensemble = ens_Ft | ens_B
                    
                    ensemble.add(init(b))
                    
                    liste=list(ensemble)
                    liste.sort(ordreRitt)
                                        
                    D.append(liste)

    return Z
    
    def syst_collecte(syst_dep,famille):
    
    """Calcul à partir d'un système de départ, le système tranché collecté"""
    
    syst_collecte = set()
    
    for equation in syst_dep:
        
        if not isinstance(equation[0],np.ndarray):
            
            membre_gauche = equation[0].forme_parametrique(A)
            
            membre_gauche = array([membre_gauche.bas,membre_gauche.haut])
        
        else :
            membre_gauche = equation[0]
        
        if not isinstance(equation[1],np.ndarray):
            
            membre_droite = equation[1].forme_parametrique(A)
            
            membre_droite = array([membre_droite.bas,membre_droite.haut])
        
        else :
            membre_droite = equation[1]
            
        equation_homogene = membre_gauche - membre_droite
        print("EQUATION HOMOGENE:")
        print(equation_homogene)
         
        if famille == 'Lin':

            syst_collecte = syst_collecte.union((equation_homogene)[0].coefficients())
            syst_collecte = syst_collecte.union((equation_homogene)[1].coefficients())
        
        if famille == 'Quad':
            
            syst_collecte = syst_collecte.union((equation_homogene)[0][0].coefficients())
            syst_collecte = syst_collecte.union((equation_homogene)[0][1].coefficients())
            syst_collecte = syst_collecte.union((equation_homogene)[1][0].coefficients())
            syst_collecte = syst_collecte.union((equation_homogene)[1][1].coefficients())
        
        liste=list(syst_collecte)
        liste.sort()
  
        
    return liste
    
    def prodInit(B):
    
    "Renvoie le produit des initiaux des polynômes de l'ensemble B"
    
    prod = 1
    
    for b in B:
        
        prod*=init(b)
        
    return prod

def ensInit(Z):
    
    "Renvoie la liste des produits des initiaux pour chaque ensemble de Z"
    
    liste = []
    
    for ensemble in Z:
        
        liste.append(prodInit(ensemble))
        
    return liste
    
    def solveFuzzyPolynomialSystem(syst_depart,famille):
    
    """Algorithme principal de résolution de systèmes de polynômes à coefficients flous triangulaires"""
    
    collecte=syst_collecte(syst_depart,famille)
    
    print("Le système tranché collecté est composé des polynômes suivants :")
    print(collecte)
    print("Calcul de l'ensemble des ensembles caractéristiques du système tranché collecté :")
    resultat = Wu(collecte)
    return (resultat,ensInit(resultat))
