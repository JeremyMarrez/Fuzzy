# Bibliothèque Fuzzy

# Modélisation de nombres flous et résolution de systèmes de polynômes à coefficients flous triangulaires ou réels

# Auteur : Jérémy Marrez

%matplotlib inline
	import matplotlib.pyplot as plt # side-stepping mpl backend
	import matplotlib.gridspec as gridspec # subplots
	

	# Make a legend for specific lines.
	import matplotlib.pyplot as plt
	import numpy as np
	from numpy import *
	

	from sage.all import *
	

	A = QQ['r']
	r = A.gen()
	A
	

	add = 1
	

	from operator import truediv
	

	class FuzzyNumber :
	    """Cette classe permet de créer et de manipuler des nombres flous non réduits (noyau = [leftMode, rightMode])"""
	

	    
	    def __init__(self, leftMode, rightMode, leftSpread, rightSpread, leftType, rightType) :
	        
	        """Constructeur de FuzzyNumber.
	        leftMode : la borne gauche du noyau du nombre flou
	        rightMode : la borne droite du noyau du nombre flou
	        leftSpread : la propagation du nombre flou à gauche du noyau
	        rightSpread : la propagation du nombre flou à droite du noyau
	        leftType : le type de la restriction de la fontion d'appartenance à gauche du noyau
	        rightType : le type de la restriction de la fontion d'appartenance à droite du noyau
	        """
	        
	        self.leftMode = leftMode
	        self.rightMode = rightMode
	        
	        self.leftSpread = leftSpread
	        self.rightSpread = rightSpread 
	        
	        self. leftType = leftType
	        self.rightType = rightType
	    
	    def __str__(self) :
	        
	        """Affiche le nombre flou sous la forme du quadruplet (tuple)
	        (leftMode, rightMode, leftSpread, rightSpread) et précise sa family"""
	        
	        return "({0},{1},{2},{3}), {4} - {5}".format(self.leftMode, self.rightMode, self.leftSpread, self.rightSpread, self.leftType, self.rightType)
	    
	    def equalFamilies(self, other):
	        
	        """Vérifie si les families de self et other sont les mêmes"""
	        
	        if(self.leftType == other.leftType) and (self.rightType == other.rightType):
	            
	            return True
	        
	        else:
	            
	            return False
	        
	    def symmetricalFamilies(self, other):
	        
	        """Vérifie si les families de self et other sont symétriques"""
	        
	        if(self.leftType == other.rightType) and (self.rightType == other.leftType):
	            
	            return True
	        
	        else:
	            
	            return False
	    
	    def __neg__(self) :
	        
	        """Renvoie l'opposé du nombre flou passé en entrée"""
	        
	        return FuzzyNumber(-self.rightMode,\
	                          -self.leftMode,\
	                          self.rightSpread,\
	                          self.leftSpread,\
	                          self.rightType,\
	                          self.leftType)
	        
	    def __add__(self, other) :
	        
	        """Redefinition of +"""
	        
	        if isinstance(other,FuzzyNumberPM) : # si other est un nombre flou, on effectue l'opération avec self sous forme paramétrique
	            
	            nbPM = self.forme_parametrique()
	            
	            return nbPM + other
	        
	        elif isinstance(other,np.ndarray) : # si other est un tableau, on effectue l'opération avec self sous forme paramétrique
	                                                # et on renvoie un tableau des fonctions top et bottom
	            nbPM = self.forme_parametrique(A)
	            
	            tab = array( [nbPM.bottom,nbPM.top] )
	            
	            return tab + other
	        
	        elif isinstance(other,sage.rings.polynomial.polynomial_element.Polynomial_generic_dense):
	            global add
	            add = (add +1)%2
	            
	            nbPM = self.forme_parametrique(A)
	            
	            if(add==0):
	                return nbPM.bottom + other
	            
	            if(add==1):
	                return nbPM.top + other
	        
	        else :
	            if not self.equalFamilies(other):
	                print("L'opération ne peut aboutir car les families des opérandes sont différentes")
	                
	            else :
	                return FuzzyNumber(self.leftMode + other.leftMode,\
	                          self.rightMode + other.rightMode,\
	                          self.leftSpread + other.leftSpread,\
	                          self.rightSpread + other.rightSpread,\
	                          self.leftType,\
	                          self.rightType)
	            
	    def __radd__(self, other):
	        
	        return self + other      
	    
	    def __sub__(self,other) :
	        
	        """Redefinition of -"""                
	            
	        if not self.symmetricalFamilies(other):
	            print("L'opération ne peut aboutir car les families des opérandes ne sont pas symétriques")
	            
	        else :
	

	            return self + -other
	        
	    def __mul__(self, other) :
	        
	        """Redefinition of *"""
	        
	        if not isinstance(other,FuzzyNumber) : # si other n'est pas un nombre flou, on effectue l'opération avec self sous forme paramétrique
	            
	            nbPM = self.forme_parametrique(A)
	            
	            tab = array( [nbPM.bottom,nbPM.top] )
	            
	            return tab*other
	        
	        else :
	            
	            if not self.equalFamilies(other):
	                print("L'opération ne peut aboutir car les families des opérandes sont différentes")
	            
	            else :
	                 
	                return FuzzyNumber(min(self.leftMode*other.leftMode,self.leftMode*other.rightMode,self.rightMode*other.leftMode,\
	                          self.rightMode*other.rightMode),max(self.leftMode*other.leftMode,self.leftMode*other.rightMode,\
	                          self.rightMode*other.leftMode, self.rightMode*other.rightMode),\
	                          (abs(self.leftMode) * other.leftSpread) + (abs(other.leftMode) * self.leftSpread),\
	                          (abs(self.rightMode) * other.rightSpread) + (abs(other.rightMode) * self.rightSpread),\
	                          self.leftType,\
	                          self.rightType)
	            
	    def __rmul__(self, other):
	        
	        return self * other
	        
	    def __invert__(self) :
	        """Renvoie l'inverse du nombre flou passé en entrée"""
	        
	        if self.leftMode.denominator()**2 == self.leftSpread.denominator() :
	            inverse = FuzzyNumber(min(1/self.leftMode,1/self.rightMode),\
	                                 max(1/self.leftMode,1/self.rightMode),\
	                                 self.rightSpread / (self.rightMode**2),\
	                                 self.leftSpread / (self.leftMode**2),\
	                                 self.rightType,\
	                                 self.leftType)
	        else :
	            inverse = FuzzyNumber(min(1/self.leftMode,1/self.rightMode),\
	                                 max(1/self.leftMode,1/self.rightMode),\
	                                 self.rightSpread / (self.leftMode**2),\
	                                 self.leftSpread / (self.rightMode**2),\
	                                 self.rightType,\
	                                 self.leftType)
	            
	        return inverse
	        
	    def __div__(self,other) :
	        
	        """Redefinition of /"""
	        
	        if not self.symmetricalFamilies(other):
	            print("L'opération ne peut aboutir car les families des opérandes ne sont pas symétriques")
	            
	        else :
	

	            return self * ~other
	    
	    def maxi(cls,fuzzyNumber1,fuzzyNumber2) :
	        
	        """Renvoie le max de deux nombres flous"""
	        
	        if fuzzyNumber2.rightMode > fuzzyNumber1.rightMode :
	            print("etape 1")
	            return fuzzyNumber2
	        
	        elif fuzzyNumber1.rightMode == fuzzyNumber2.rightMode :
	            print("etape 2")
	            return FuzzyNumber(max(fuzzyNumber1.leftMode , fuzzyNumber2.leftMode),\
	                          max(fuzzyNumber1.rightMode , fuzzyNumber2.rightMode),\
	                          min(fuzzyNumber1.leftSpread , fuzzyNumber2.leftSpread),\
	                          max(fuzzyNumber1.rightSpread , fuzzyNumber2.rightSpread),\
	                          self.leftType,\
	                          self.rightType)
	        else :
	            print("etape 3")
	            return fuzzyNumber1
	        
	    maxi = classmethod(maxi)
	 
	    def mini(cls,fuzzyNumber1,fuzzyNumber2) :
	        
	        """Renvoie le min de deux nombres flous"""
	        
	        if fuzzyNumber2.leftMode > fuzzyNumber1.leftMode :
	            
	            return fuzzyNumber1
	        
	        elif fuzzyNumber1.leftMode == fuzzyNumber2.leftMode :
	

	            return FuzzyNumber(min(fuzzyNumber1.leftMode , fuzzyNumber2.leftMode),\
	                          min(fuzzyNumber1.rightMode , fuzzyNumber2.rightMode),\
	                          max(fuzzyNumber1.leftSpread , fuzzyNumber2.leftSpread),\
	                          min(fuzzyNumber1.rightSpread , fuzzyNumber2.rightSpread),\
	                          self.leftType,\
	                          self.rightType)
	        else :
	            
	            return fuzzyNumber2
	        
	    mini = classmethod(mini)
	    
	    def equal(self, other):
	        
	        """Redefinition of =="""
	        
	        if (self.leftMode == other.leftMode) * (self.rightMode == other.rightMode) * (self.leftSpread == other.leftSpread) * (self.rightSpread == other.rightSpread)\
	            * (self.leftType == other.leftType) * (self.rightType == other.rightType):
	            return True
	        
	        else:
	            return False        
	        
	    def greather_than(self,other) :
	        
	        """Redefinition of > comme ordre partiel"""
	        
	        maximum = FuzzyNumber.maxi(self,other)
	        
	        if(maximum == self):
	            return True
	     
	        elif(maximum == other):
	            return False
	    
	        else:
	            print("Ces deux arguments ne sont pas comparables pour cette relation d'ordre partiel")
	            
	    def lower_than(self,other) :
	        
	        """Redefinition of < comme ordre partiel"""
	        
	        minimum = FuzzyNumber.mini(self,other)
	        
	        if(minimum == self):
	            return True
	     
	        elif(minimum == other):
	            return False
	    
	        else:
	            print("Ces deux arguments ne sont pas comparables pour cette relation d'ordre partiel")
	

	    def trace(self):
	        
	        """Affichage graphique de la fonction d'appartenance du nombre flou en fonction des types
	        de ses restrictions à gauche et à droite de son noyau"""
	        
	        if self.leftType == "Lin" :
	            
	            G = plot((x -self.leftMode)/self.leftSpread+1,(x,self.leftMode - self.leftSpread,self.leftMode),color='red')
	            
	        elif self.leftType == "Exp" :
	            
	            G = plot(1 - exp((-(x - self.leftMode + self.leftSpread)**2)/self.leftSpread),(x,self.leftMode - self.leftSpread,self.leftMode),color='red')
	            
	        elif self.leftType == "Quad" :
	            
	            G1 = plot(2 * ( (x- self.leftMode + self.leftSpread) / (self.leftSpread))**2,(x,self.leftMode-self.leftSpread, self.leftMode-(self.leftSpread/2)),color='red')
	            
	            G2 = plot(1 - 2 * ( (x- self.leftMode) / (self.leftSpread))**2,(x,self.leftMode-(self.leftSpread/2), self.leftMode),color='red')
	            
	            G=G1+G2
	            
	        if self.rightType == "Lin" :    
	            
	            D = plot((self.rightMode - x)/self.rightSpread+1,(x,self.rightMode,self.rightMode + self.rightSpread),color='green')
	            
	        elif self.rightType == "Exp" :
	            
	            D = plot( 1 - exp((-( -x + self.rightMode + self.rightSpread)**2)/self.rightSpread),(x,self.rightMode,self.rightMode + self.rightSpread),color='green')
	

	        elif self.rightType == "Quad":
	            
	            D1 = plot( 1 - 2 * ( (x - self.rightMode) / (self.rightSpread))**2,(x,self.rightMode, self.rightMode+(self.rightSpread/2)),color='green')
	            
	            D2 = plot(2 * ( ( x - self.rightMode - self.rightSpread) / (self.rightSpread))**2,(x,self.rightMode+(self.rightSpread/2), self.rightMode+self.rightSpread),color='green')
	            D=D1+D2
	        
	        if not isinstance(self,RedFuzzyNumber) and (self.leftMode != self.rightMode) :
	            M = plot(1,(x,self.leftMode,self.rightMode))
	            return (G+M+D)
	        
	        return (G+D)
	   
	    def trace2(self):
	        
	        """Affichage graphique en MathLab de la fonction d'appartenance du nombre flou en fonction des types
	        de ses restrictions à gauche et à droite de son noyau"""
	

	        if self.leftType == "Lin":
	            g = np.arange(self.leftMode-self.leftSpread, self.leftMode,0.001)
	            lg = plt.plot(g, ((g-self.leftMode)/self.leftSpread) +1)
	            
	        elif self.leftType == "Quad" :
	            
	            g1 = np.arange(self.leftMode-self.leftSpread, self.leftMode-(self.leftSpread/2),0.001)
	            g2 = np.arange(self.leftMode-(self.leftSpread/2), self.leftMode,0.001)
	            
	            lg1 = plt.plot(g1, 2 * ( (g1- self.leftMode + self.leftSpread) / (self.leftSpread))**2)
	            lg2 = plt.plot(g2, 1 - 2 * ( (g2- self.leftMode) / (self.leftSpread))**2)
	            
	            
	        if self.rightType == "Lin" :
	            d = np.arange(self.rightMode, self.rightMode + self.rightSpread,0.001)
	            ld = plt.plot(d, ((-d+self.rightMode)/self.rightSpread) +1)
	            
	        elif self.rightType == "Quad" :
	            
	            d1 = np.arange(self.rightMode, self.rightMode+(self.rightSpread/2),0.001)
	            d2 = np.arange(self.rightMode+(self.rightSpread/2), self.rightMode+self.rightSpread,0.001)    
	            
	            ld1 = plt.plot(d1, 1 - 2 * ( (d1 - self.rightMode) / (self.rightSpread))**2)
	            ld2 = plt.plot(d2, 2 * ( ( d2 - self.rightMode - self.rightSpread) / (self.rightSpread))**2)
	    
	    def forme_parametrique(self,A=None):
	        
	        """Passage à la forme paramétrique du nombre flou à partir d'un anneau de polynômes univariés,
	        en fonction des types de ses restrictions à gauche et à droite de son noyau"""
	           
	        if A is None :     # si aucun anneau n'est passé en paramètre
	            B = QQ['r']
	            r = B.gen()    # on récupère le générateur de l'anneau par défaut
	

	            C=QQ['u,v']
	            u, v = C.gens()[0], C.gens()[1]
	                                            
	        else:
	            B = A['r']
	            r = B.gen()    # sinon on récupère le générateur de l'anneau
	            
	            C=A['u,v']
	            u, v = C.gens()[0], C.gens()[1]
	            
	        if self.leftType == "Lin" :
	            
	            bottom = self.leftMode + self.leftSpread * (r-1)
	            
	        elif self.leftType == "Exp" :
	            
	            bottom = self.leftMode - self.leftSpread + sqrt(-self.leftSpread*log(1-r))
	        
	        elif self.leftType == "Quad" :
	            
	            bottom1 = self.leftMode + self.leftSpread * (u-1)
	            bottom2 = self.leftMode - self.leftSpread * v
	            bottom = array( [bottom1,bottom2] )
	

	        if self.rightType == "Lin" :
	            
	            top = self.rightMode + self.rightSpread * (1-r)
	            
	        elif self.rightType == "Exp" :
	            
	            top = self.rightMode + self.rightSpread - sqrt(-self.rightSpread*log(1-r))
	            
	        elif self.rightType == "Quad" :
	        
	            top1 = -(-self.rightMode - self.rightSpread * v)
	            top2 = -(-self.rightMode + self.rightSpread * (u-1) )
	            top = array( [top1,top2] )
	            
	        # on construit alors un nombre flou sous forme paramétrique avec les deux fonctions et les types des restrictions
	        
	        if A is None :    
	            
	            return FuzzyNumberPM(bottom, top, self.leftType + " - " + self.rightType)
	        
	        else :
	            
	            return FuzzyNumberPM(bottom, top, self.leftType + " - " + self.rightType,A)
	

	class RedFuzzyNumber(FuzzyNumber):
	    
	    """Cette classe permet de créer et de manipuler des nombres flous réduit (noyau = mode).
	    
	    Elle hérite de la classe des nombres flous non réduits"""
	

	    
	    def __init__(self, mode, leftSpread, rightSpread, leftType, rightType) :
	              
	        """Constructeur de RedFuzzyNumber.
	        Mode : le noyau du nombre flou
	        leftSpread : la propagation du nombre flou à gauche du noyau
	        rightSpread : la propagation du nombre flou à droite du noyau
	        leftType : le type de la restriction de la fontion d'appartenance à gauche du noyau
	        rightType : le type de la restriction de la fontion d'appartenance à droite du noyau
	        """
	        
	        self.leftMode = self.rightMode = mode    # le noyau est réduit à un élément
	        
	        self.leftSpread=leftSpread
	        self.rightSpread=rightSpread
	        
	        self.leftType = leftType
	        self.rightType = rightType
	        
	    def get_mode(self):
	        
	        return self.leftMode
	        
	    def get_leftSpread(self):
	        
	        return self.leftSpread
	    
	    def get_rightSpread(self):
	        
	        return self.rightSpread
	        
	    def __str__(self) :
	        
	        """Affiche le nombre flou sous la forme du triplet (tuple)
	        (mode, leftSpread, rightSpread) et précise sa family"""
	        
	        return "({0},{1},{2}), {3} - {4}".format(self.leftMode, self.leftSpread, self.rightSpread, self.leftType, self.rightType)
	    
	    def __neg__(self) :
	        
	        """Renvoie l'opposé du nombre flou passé en entrée"""
	        
	        return RedFuzzyNumber(-self.leftMode,\
	                          self.rightSpread,\
	                          self.leftSpread,\
	                          self.rightType,\
	                          self.leftType)
	        
	    def __add__(self, other) :
	        
	        """Redefinition of +"""
	        
	        if isinstance(other,FuzzyNumberPM) : # si other est un nombre flou, on effectue l'opération avec self sous forme paramétrique
	            
	            nbPM = self.forme_parametrique()
	            
	            return nbPM + other
	        
	        elif isinstance(other,np.ndarray) : # si other est un tableau, on effectue l'opération avec self sous forme paramétrique
	                                                # et on renvoie un tableau des fonctions top et bottom
	            nbPM = self.forme_parametrique(A)
	            
	            tab = array( [nbPM.bottom,nbPM.top] )
	            
	            return tab + other
	        
	        elif isinstance(other,sage.rings.polynomial.polynomial_element.Polynomial_generic_dense) or isinstance(other,sage.rings.polynomial.multi_polynomial_element.MPolynomial_polydict):
	            global add
	            add = (add +1)%4
	            
	            nbPM = self.forme_parametrique(A)
	            
	            if self.leftType == 'Lin' :
	                       
	                if(add%2==0):
	                    return nbPM.bottom + other
	            
	                elif(add%2==1):
	                    return nbPM.top + other
	                
	            if self.leftType == 'Quad':
	                
	                if(add==0):
	                    return nbPM.bottom[0] + other
	            
	                elif(add==1):
	                    return nbPM.bottom[1] + other
	                
	                elif(add==2):
	                    return nbPM.top[0] + other
	            
	                elif(add==3):
	                    return nbPM.top[1] + other
	                            
	        else :
	            if not self.equalFamilies(other):
	                print("L'opération ne peut aboutir car les families des opérandes sont différentes")
	                
	            else :
	                return RedFuzzyNumber(self.leftMode + other.leftMode,\
	                          self.leftSpread + other.leftSpread,\
	                          self.rightSpread + other.rightSpread,\
	                          self.leftType,\
	                          self.rightType)
	            
	    def __radd__(self, other):
	        
	        return self + other 
	        
	    def __mul__(self, other) :
	        
	        """Redefinition of *"""
	        
	        if not isinstance(other,FuzzyNumber) : # si other n'est pas un nombre flou, on effectue l'opération avec self sous forme paramétrique
	            
	            nbPM = self.forme_parametrique(A)
	            
	            tab = array( [nbPM.bottom,nbPM.top] )
	            
	            return tab*other
	        
	        else :
	                
	            if not self.equalFamilies(other):
	                print("L'opération ne peut aboutir car les families des opérandes sont différentes")
	            
	            else :
	                 
	                return RedFuzzyNumber(self.leftMode*other.leftMode,\
	                          (abs(self.leftMode) * other.leftSpread) + (abs(other.leftMode) * self.leftSpread),\
	                          (abs(self.rightMode) * other.rightSpread) + (abs(other.rightMode) * self.rightSpread),\
	                          self.leftType,\
	                          self.rightType)
	        
	    def __invert__(self) :
	        
	        """Renvoie l'inverse du nombre flou passé en entrée"""
	        
	        inverse = RedFuzzyNumber(1/self.leftMode, self.rightSpread / (self.rightMode**2),\
	                                    self.leftSpread / (self.leftMode**2),\
	                                    self.rightType,\
	                                    self.leftType)
	            
	        return inverse
	

	class FuzzyNumberPM :
	    """Cette classe permet de créer et de manipuler des nombres flous sous la forme paramétrique"""
	    
	    def __init__(self, bottom, top, family, A=None) :
	        
	        """Constructeur de FuzzyNumber.
	        bottom : le polynôme qui donne pour chaque r dans [0,1] la borne gauche de la coupe-r correspondante
	        top : le polynôme qui donne pour chaque r dans [0,1] la borne droite de la coupe-r correspondante
	        family : la family du nombre flou
	        para : le générateur de l'anneau donné en paramètre (ou par défaut le générateur de l'anneau de polynômes à une variable sur le corps de rationnels)
	        """
	        if A is None:
	            self.bottom=bottom
	            self.top=top
	            self.family = family
	            A = QQ[r]
	            self.para = A.gen()
	            
	        else :
	            
	            self.bottom = bottom
	            self.top = top
	            self.family = family
	            self.para = A.gen()
	        
	    def __str__(self) :
	        
	        """Affiche le nombre flou sous la forme d'une liste
	        [bottom, top], family"""
	        
	        if isinstance(self.bottom, np.ndarray):
	            
	            bottom = list(self.bottom)
	            
	        else :
	            
	            bottom = self.bottom
	            
	        if isinstance(self.top, np.ndarray):
	            
	            top = list(self.top)  
	            
	        else :
	            
	            top = self.top
	        
	        return "[{0},{1}] , {2}".format(bottom, top, self.family)
	    
	    def get_types(self):
	        
	        """À partir de la family du nombre flou paramétrique, renvoie les types des restrictions"""
	        
	        tiret = False
	        leftType = ''
	        rightType = ''
	        
	        for lettre in self.family :
	            if lettre == '-':
	                
	                tiret = True
	                
	            elif tiret == False:
	                
	                leftType += lettre
	                
	            else :
	                
	                rightType += lettre
	        
	        leftType = leftType.strip()      
	        leftType = leftType.capitalize()
	        rightType = rightType.strip()
	        rightType = rightType.capitalize()
	    
	        return leftType, rightType
	    
	    def equalFamilies(self, other):
	        
	        """Vérifie si les families de self et other sont les mêmes"""
	        
	        if(self.get_types()[0] == other.get_types()[0]) and (self.get_types()[1] == other.get_types()[1]):
	            
	            return True
	        
	        else:
	            
	            return False
	        
	    def symmetricalFamilies(self, other):
	        
	        """Vérifie si les families de self et other sont symétriques"""
	        
	        if(self.get_types()[0] == other.get_types()[1]) and (self.get_types()[1] == other.get_types()[0]):
	            
	            return True
	        
	        else:
	            
	            return False
	    
	    def __neg__(self):
	        
	        """Renvoie l'opposé du nombre flou paramétrique"""
	        
	        if self.get_types()[0] == 'Quad' :
	            
	            bottom = array( [self.bottom[1],self.bottom[0]] )
	            
	        else :
	            
	            bottom = self.bottom
	            
	        if self.get_types()[1] == 'Quad' :
	            
	            top = array( [self.top[1],self.top[0]] )
	            
	        else :
	            
	            top = self.top
	        
	        return FuzzyNumberPM( - top, - bottom, self.get_types()[1] + " - " + self.get_types()[0], self.para.parent())
	    
	    def __add__(self, other):
	        
	        """Redefinition of +"""
	        
	        if isinstance(other,FuzzyNumber) or isinstance(other,RedFuzzyNumber) : # si other est un Nombre flou sous forme de tuple, l'opération s'effectue après avoir passé other sous forme paramétrique
	            
	            copy_other = other.forme_parametrique()
	                      
	        else :
	            
	            copy_other = other
	        
	        if not self.equalFamilies(copy_other):
	            print("L'opération ne peut aboutir car les families des opérandes sont différentes")
	            
	        else :
	            return FuzzyNumberPM(self.bottom + copy_other.bottom, self.top + copy_other.top, self.family, self.para.parent())
	    
	    def __sub__(self, other):
	        
	        """Redefinition of -"""
	            
	        if not self.symmetricalFamilies(other):
	            print("L'opération ne peut aboutir car les families des opérandes ne sont pas symétriques")
	            
	        else :
	            
	            return self + -other
	

	    
	    def __mul__(self, other):
	       
	        """Redefinition of *"""
	

	         # Premier cas : cas d'un produit par un scalaire ou un polynôme isinstance(other,float) :
	        
	        if not isinstance(other, FuzzyNumberPM):
	            
	            if(other < 0):
	                return FuzzyNumberPM(other * self.top, other * self.bottom, self.family, self.para.parent())
	        
	            else :
	                return FuzzyNumberPM(other * self.bottom, other * self.top, self.family, self.para.parent())
	

	            # Second cas : cas d'un produit par un other nombre flou
	        
	        else:
	            if not self.equalFamilies(other):
	                print("L'opération ne peut aboutir car les families des opérandes sont différentes")
	            else:    
	                return FuzzyNumberPM( min(self.bottom * other.bottom,self.bottom * other.top,self.top * other.bottom,self.top * other.top) ,\
	                                max(self.bottom * other.bottom,self.bottom * other.top,self.top * other.bottom,self.top * other.top),\
	                                self.family, self.para.parent())
	            
	            
	    def __div__(self, other):
	        
	        """Redefinition of /"""
	        
	        if not self.symmetricalFamilies(other):
	            print("L'opération ne peut aboutir car les families des opérandes ne sont pas symétriques")
	            
	        else :
	        
	            if  other.bottom(0) < 0 < other.top(0):
	                return FuzzyNumberPM( min(self.bottom / other.bottom,self.bottom / other.top,self.top / other.bottom,self.top / other.top) ,\
	                                max(self.bottom / other.bottom,self.bottom / other.top,self.top / other.bottom,self.top / other.top),\
	                                self.family, self.para.parent())
	            
	    def forme_tuple(cls,FuzzyNumberPM):
	        
	        
	        leftMode = FuzzyNumberPM.bottom(1)
	        
	        rightMode = FuzzyNumberPM.top(1) 
	        
	        leftSpread = (-1) * (FuzzyNumberPM.bottom(0) - leftMode)
	        
	        rightSpread = (FuzzyNumberPM.top(0) - rightMode)
	        
	        if(FuzzyNumberPM.family == 'NombreFlouTrap') :
	            return NombreFlouTrap(leftMode, rightMode, leftSpread, rightSpread)
	

	        if(FuzzyNumberPM.family == 'NombreFlouTri') :
	            return NombreFlouTri(leftMode, leftSpread, rightSpread)
	    
	

	    forme_tuple = classmethod(forme_tuple)
	    
	    def ff(self): 
	        r=self.para
	        Bottom=self.bottom
	        Top=self.top
	        return (Bottom(r) + Top(r) + Bottom(1) + Top(1))*r
	        #return (self.bottom(r) + self.top(r) + self.bottom(1) + self.top(1))*r
	    
	    def mag2(self):
	        return integral(self.ff(),r)
	    
	    def mag(self):
	        
	        r=self.para
	        
	        """Calcule la magnitude du nombre flou"""
	        
	        f=(self.bottom(r) + self.top(r) + self.bottom(1) + self.top(1))*r
	        
	        integrale = integral(f(r),r)
	        
	        res = truediv(integrale(1) - integrale(0),2)
	        
	        return res
	    
	    def momag(self):
	        
	        """Calcule la momagnitude du nombre flou"""
	        
	        f=(self.bottom(r) - self.top(r) + self.bottom(1) - self.top(1))
	        
	        integrale = integral(f(r),r)
	        
	        res = truediv(integrale(1) - integrale(0),2)
	        
	        return res
	    
	    def R(self, other):
	        
	        """À partir de 2 nombres flous sous forme paramétrique A et B, calcule les quantités 
	        
	        R(A,lambda) = Mag(A) + lambda * Momag(A) et R(B,lambda) = Mag(B) + lambda * Momag(B),
	        
	        où lambda = 0 si Mag(A) != Mag(B)
	                    1 si Mag(A) == Mag(B) et z >= 0
	                    -1 si Mag(A) == Mag(B) et z < 0
	                    
	        avec z = (A.bottom(1) + A.top(1))/2
	        
	        et renvoie ces deux valeurs dans un tuple"""
	        
	        if (self.mag()!= other.mag()) :
	            
	            return (self.mag(),other.mag())
	        
	        else:
	            
	            z = truediv(self.bottom(1) + self.top(1),2)
	                  
	            if(z >=0):
	                
	                return (self.mag() + self.momag(), other.mag() + other.momag())
	            
	            else :
	                
	                 return (self.mag() - self.momag(), other.mag() - other.momag())
	        
	    
	    def __eq__(self, other):
	        
	        """Redefinition of =="""
	        
	        if(self.R(other)[0] == self.R(other)[1]) :
	            
	            return True
	        
	        else :
	            
	            return False
	        
	    def __ne__(self, other):
	        
	        """Redefinition of !="""
	        
	        if(self.R(other)[0] != self.R(other)[1]) :
	            
	            return True
	        
	        else :
	            
	            return False
	        
	    def __lt__(self, other):
	        
	        """Redefinition of <"""
	        
	        if(self.R(other)[0] < self.R(other)[1]) :
	            
	            return True
	        
	        else :
	            
	            return False
	        
	    def __le__(self, other):
	        
	        """Redefinition of <="""
	        
	        if(self.R(other)[0] <= self.R(other)[1]) :
	            
	            return True
	        
	        else :
	            
	            return False
	        
	    def __gt__(self, other):
	        
	        """Redefinition of >"""
	        
	        if(self.R(other)[0] > self.R(other)[1]) :
	            
	            return True
	        
	        else :
	            
	            return False
	        
	    def __ge__(self, other):
	        
	        """Redefinition of >="""
	        
	        if(self.R(other)[0] >= self.R(other)[1]) :
	            
	            return True
	        
	        else :
	            
	            return False
	        
	    def maximum(cls,fuzzyNumber1,fuzzyNumber2) :
	        
	        """Renvoie le max de deux nombres flous pour l'ordre total"""
	        
	        if fuzzyNumber1 == fuzzyNumber2 :
	            
	            print("Les deux nombres flous sont équivalents, renvoi du premier passé en paramètre")
	            
	            return fuzzyNumber1
	        
	        elif fuzzyNumber1 > fuzzyNumber2 :
	            
	            return fuzzyNumber1
	        
	        else :
	            
	            return fuzzyNumber2
	            
	    maximum = classmethod(maximum)
	    
	    def minimum(cls,fuzzyNumber1,fuzzyNumber2) :
	        
	        """Renvoie le min de deux nombres flous pour l'ordre total"""
	        
	        if fuzzyNumber1 == fuzzyNumber2 :
	            
	            print("Les deux nombres flous sont équivalents, renvoi du premier passé en paramètre")
	            
	            return fuzzyNumber1
	        
	        elif fuzzyNumber1 < fuzzyNumber2 :
	            
	            return fuzzyNumber1
	        
	        else :
	            
	            return fuzzyNumber2
	            
	    minimum = classmethod(minimum)
	    
	    def maxi(cls,fuzzyNumber1,fuzzyNumber2) :
	        
	        """Renvoie le max de deux nombres flous pour l'ordre partiel"""
	        
	        if truediv(fuzzyNumber1.top(1)+fuzzyNumber1.bottom(1),2) == truediv(fuzzyNumber2.top(1)+fuzzyNumber2.bottom(1),2):
	            
	            if fuzzyNumber1.bottom(0) >= fuzzyNumber2.bottom(0):
	                bottom = fuzzyNumber1.bottom
	                
	            else :
	                bottom = fuzzyNumber2.bottom
	                
	            if fuzzyNumber1.top(0) >= fuzzyNumber2.top(0):
	                top = fuzzyNumber1.top
	                
	            else :
	                top = fuzzyNumber2.top
	            
	            return FuzzyNumberPM(bottom,top)
	

	        elif truediv(fuzzyNumber1.top(1)+fuzzyNumber1.bottom(1),2) > truediv(fuzzyNumber2.top(1)+fuzzyNumber2.bottom(1),2):
	            return fuzzyNumber1
	        
	        else :
	            return fuzzyNumber2
	        
	    maxi = classmethod(maxi)
	 
	    def mini(csl,fuzzyNumber1,fuzzyNumber2) :
	        
	        """Renvoie le min de deux nombres flous pour l'ordre partiel"""
	        
	        if truediv(fuzzyNumber1.top(1)+fuzzyNumber1.bottom(1),2) == truediv(fuzzyNumber2.top(1)+fuzzyNumber2.bottom(1),2):
	            
	            if fuzzyNumber1.bottom(0) < fuzzyNumber2.bottom(0):
	                bottom = fuzzyNumber1.bottom
	                
	            else :
	                bottom = fuzzyNumber2.bottom
	                
	            if fuzzyNumber1.top(0) < fuzzyNumber2.top(0):
	                top = fuzzyNumber1.top
	                
	            else :
	                top = fuzzyNumber2.top
	            
	            return FuzzyNumberPM(bottom,top)
	

	        elif truediv(fuzzyNumber1.top(1)+fuzzyNumber1.bottom(1),2) < truediv(fuzzyNumber2.top(1)+fuzzyNumber2.bottom(1),2):
	            return fuzzyNumber1
	        
	        else :
	            return fuzzyNumber2
	        
	    mini = classmethod(mini)
	    
	    def equal(self, other):
	        
	        """Redefinition of == comme ordre partiel"""
	        
	        if (self.bottom == other.bottom) * (self.top == other.top) :
	            return True
	        
	        else:
	            return False        
	        
	    def greather_than(self,other) :
	        
	        """Redefinition of > comme ordre partiel"""
	        
	        maximum = FuzzyNumberPM.maxi(self,other)
	        
	        if(maximum == self):
	            return True
	     
	        elif(maximum == other):
	            return False
	    
	        else:
	            print("Ces deux arguments ne sont pas comparables pour cette relation d'ordre partiel")
	            
	    def lower_than(self,other) :
	        
	        """Redefinition of > comme ordre partiel"""
	        
	        minimum = FuzzyNumberPM.mini(self,other)
	        
	        if(minimum == self):
	            return True
	     
	        elif(minimum == other):
	            return False
	    
	        else:
	            print("Ces deux arguments ne sont pas comparables pour cette relation d'ordre partiel")
	                       
	    def trace(self):
	        
	        """Affichage graphique de la fonction d'appartenance du nombre flou en fonction des fonctions bottom et top"""
	        
	        if self.get_types()[0] == "Quad":
	            
	            G1 = plot(self.bottom[0](x),(x,0,0.5),color='red')
	            
	            G2 = plot(self.bottom[1](x),(x,0.5,1),color='red')
	            
	            G=G1+G2
	            
	            leftLim = self.bottom[1](1)
	            
	        else:
	            
	            G = plot(self.bottom(x),(x,0,1),color='red')
	            
	            leftLim = self.bottom(1)
	            
	        if self.get_types()[1] == "Quad":
	            
	            D1 = plot(self.top[0](x),(x,0.5,1),color='green')
	            
	            D2 = plot(self.top[1](x),(x,0,0.5),color='green')
	            D=D1+D2
	            
	            rightLim = self.top[0](1)
	            
	        else:
	            
	            D = plot(self.top(x),(x,0,1),color='green')
	            
	            rightLim = self.top(1)
	            
	        M = line([(1,rightLim), (1,leftLim)])
	        
	        return (G+M+D)
	    
	    def trace2(self):
	        
	        """Affichage graphique en MathLab de la fonction d'appartenance du nombre flou en fonction des fonctions bottom et top"""
	

	        t = np.arange(0.0, 1.0,0.001)
	        
	        if self.get_types()[0] == "Quad":
	            
	            bottom1=self.bottom[0]
	            bottom2=self.bottom[1]
	            print(bottom2)
	            lg1 = plt.plot(t, bottom1(t))
	            lg2 = plt.plot(t, bottom2(t))
	        
	        else:
	            
	            lg = plt.plot(t, self.bottom(t))
	        
	        if self.get_types()[1] == "Quad":
	 
	            ld1 = plt.plot(t, self.top[0](t))
	            ld2 = plt.plot(t, self.top[1](t))
	        
	        else:
	            
	            ld = plt.plot(t, self.top(t))    
